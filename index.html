<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Flores virtuales</title>
  <style>
    :root{
      --bg1:#0b0f1a;
      --bg2:#101a2d;
      --txt:rgba(255,255,255,.88);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;
      color:var(--txt);
      background:radial-gradient(1200px 700px at 20% 10%, var(--bg2), var(--bg1));
      overflow:hidden;
    }
    canvas{
      position:fixed;
      inset:0;
      width:100vw;
      height:100vh;
      display:block;
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: true });

  // ====== CONFIG (aquí “configuras” sin mostrar menú) ======
  const CONFIG = {
    preset: 'garden',      // 'garden' | 'neon' | 'pastel' | 'sunset' | 'mono'
    baseColor: '#ff4fd8',  // color base
    count: 90,             // cantidad de flores en pantalla
    speed: 0.35,           // 0..1 (más = más rápido)
    size: 26,              // tamaño base
    wind: 0.28,            // 0..1 (más = más viento)
    mode: 'float',         // 'float' | 'sprout' | 'orbit'
  };
  // ==========================================================

  let W = 0, H = 0, DPR = 1;
  function resize(){
    DPR = Math.min(2, window.devicePixelRatio || 1);
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);
    canvas.width = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  window.addEventListener('resize', resize);
  resize();

  // Helpers
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a, b, t) => a + (b - a) * t;
  const rand = (a, b) => a + Math.random() * (b - a);
  const randi = (a, b) => Math.floor(rand(a, b + 1));

  // Color utils
  function hexToRgb(hex){
    const h = hex.replace('#','').trim();
    const full = h.length === 3 ? h.split('').map(ch => ch+ch).join('') : h;
    const n = parseInt(full, 16);
    return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
  }
  function rgbToHsl(r, g, b){
    r/=255; g/=255; b/=255;
    const max=Math.max(r,g,b), min=Math.min(r,g,b);
    let h=0, s=0, l=(max+min)/2;
    if(max !== min){
      const d = max-min;
      s = l > 0.5 ? d/(2-max-min) : d/(max+min);
      switch(max){
        case r: h = (g-b)/d + (g < b ? 6 : 0); break;
        case g: h = (b-r)/d + 2; break;
        case b: h = (r-g)/d + 4; break;
      }
      h /= 6;
    }
    return { h, s, l };
  }
  function hslToRgb(h, s, l){
    let r, g, b;
    if(s === 0){ r=g=b=l; }
    else{
      const hue2rgb = (p, q, t) => {
        if(t < 0) t += 1;
        if(t > 1) t -= 1;
        if(t < 1/6) return p + (q - p) * 6 * t;
        if(t < 1/2) return q;
        if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
      };
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      r = hue2rgb(p, q, h + 1/3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1/3);
    }
    return { r:Math.round(r*255), g:Math.round(g*255), b:Math.round(b*255) };
  }
  function rgba({r,g,b}, a){ return `rgba(${r},${g},${b},${a})`; }

  function paletteFromPreset(baseHex, preset){
    const base = hexToRgb(baseHex);
    const hsl = rgbToHsl(base.r, base.g, base.b);

    const palettes = {
      garden: () => ([
        { h: (hsl.h + 0.00) % 1, s: clamp(hsl.s*0.95, 0.2, 0.95), l: clamp(hsl.l*1.05, 0.25, 0.75) },
        { h: (hsl.h + 0.08) % 1, s: clamp(hsl.s*0.85, 0.2, 0.95), l: clamp(hsl.l*0.95, 0.2, 0.7) },
        { h: (hsl.h + 0.16) % 1, s: clamp(hsl.s*0.90, 0.25, 0.98), l: clamp(hsl.l*0.90, 0.18, 0.7) },
        { h: (hsl.h - 0.10 + 1) % 1, s: clamp(hsl.s*0.70, 0.2, 0.9), l: clamp(hsl.l*1.10, 0.25, 0.78) },
      ]),
      neon: () => ([
        { h: (hsl.h + 0.00) % 1, s: 0.95, l: 0.60 },
        { h: (hsl.h + 0.18) % 1, s: 0.95, l: 0.58 },
        { h: (hsl.h + 0.36) % 1, s: 0.95, l: 0.56 },
        { h: (hsl.h + 0.54) % 1, s: 0.95, l: 0.54 },
      ]),
      pastel: () => ([
        { h: (hsl.h + 0.00) % 1, s: clamp(hsl.s*0.55, 0.15, 0.55), l: 0.78 },
        { h: (hsl.h + 0.12) % 1, s: clamp(hsl.s*0.50, 0.15, 0.55), l: 0.80 },
        { h: (hsl.h + 0.24) % 1, s: clamp(hsl.s*0.45, 0.15, 0.55), l: 0.76 },
        { h: (hsl.h - 0.10 + 1) % 1, s: clamp(hsl.s*0.50, 0.15, 0.60), l: 0.82 },
      ]),
      sunset: () => ([
        { h: 0.02, s: 0.90, l: 0.58 },
        { h: 0.08, s: 0.92, l: 0.60 },
        { h: 0.14, s: 0.90, l: 0.58 },
        { h: 0.86, s: 0.75, l: 0.60 },
      ]),
      mono: () => ([
        { h: hsl.h, s: clamp(hsl.s*0.25, 0.05, 0.25), l: 0.70 },
        { h: hsl.h, s: clamp(hsl.s*0.20, 0.05, 0.25), l: 0.55 },
        { h: hsl.h, s: clamp(hsl.s*0.15, 0.05, 0.25), l: 0.40 },
        { h: hsl.h, s: clamp(hsl.s*0.10, 0.05, 0.25), l: 0.28 },
      ]),
    };

    const builder = palettes[preset] || palettes.garden;
    return builder().map(p => hslToRgb(p.h, p.s, p.l));
  }

  class Flower {
    constructor(x, y, opt){
      this.x = x;
      this.y = y;
      this.z = rand(0.3, 1.0); // pseudo-depth
      this.r = opt.size * rand(0.7, 1.25) * lerp(0.75, 1.25, this.z);
      this.petals = randi(5, 10);
      this.rot = rand(0, Math.PI*2);
      this.rotSpd = rand(-0.012, 0.012) * opt.speed;
      this.vx = rand(-0.4, 0.4) * opt.wind;
      this.vy = rand(-0.8, -0.25) * opt.speed * lerp(0.5, 1.1, this.z);
      this.wobble = rand(0.6, 2.4);
      this.wobblePhase = rand(0, Math.PI*2);
      this.fade = 0;
      this.color = opt.color;
      this.center = opt.center;
      this.outline = opt.outline;
      this.mode = opt.mode;
      this.orbitA = rand(30, 180);
      this.orbitB = rand(25, 140);
      this.orbitT = rand(0, Math.PI*2);
      this.seed = Math.random();
    }

    step(t, opt){
      this.fade = clamp(this.fade + 0.02, 0, 1);

      if(this.mode === 'orbit'){
        this.orbitT += 0.004 * opt.speed * lerp(0.35, 0.9, this.z);
        const cx = W * 0.5 + Math.sin(this.seed * 9) * 160;
        const cy = H * 0.55 + Math.cos(this.seed * 7) * 110;
        this.x = cx + Math.cos(this.orbitT) * this.orbitA;
        this.y = cy + Math.sin(this.orbitT) * this.orbitB;
      } else {
        const wob = Math.sin(t * 0.002 * this.wobble + this.wobblePhase);
        this.x += this.vx + wob * 0.35 * opt.wind;
        this.y += this.vy;

        if(this.mode === 'sprout'){
          this.vy *= 0.992;
        }
      }

      this.rot += this.rotSpd;

      if(this.y < -this.r - 40 || this.x < -200 || this.x > W + 200){
        this.x = rand(0, W);
        this.y = (this.mode === 'sprout') ? H + rand(20, 220) : H + rand(10, 220);
        this.fade = 0;
        this.rot = rand(0, Math.PI*2);
        this.petals = randi(5, 10);
        this.z = rand(0.3, 1.0);
        this.r = opt.size * rand(0.7, 1.25) * lerp(0.75, 1.25, this.z);
        this.vx = rand(-0.4, 0.4) * opt.wind;
        this.vy = rand(-0.8, -0.25) * opt.speed * lerp(0.5, 1.1, this.z);
        this.rotSpd = rand(-0.012, 0.012) * opt.speed;
      }
    }

    draw(){
      const x = this.x, y = this.y, r = this.r;

      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(this.rot);

      const glow = 0.10 + 0.22 * this.z;
      ctx.shadowColor = rgba(this.color, 0.55 * this.fade);
      ctx.shadowBlur = 14 + 22 * this.z;

      for(let i=0;i<this.petals;i++){
        const a = (i / this.petals) * Math.PI * 2;
        ctx.save();
        ctx.rotate(a);

        const petalLen = r * (1.0 + 0.18 * Math.sin(i*1.7 + this.seed*10));
        const petalWid = r * 0.55;

        const g = ctx.createRadialGradient(0, 0, r*0.1, petalLen*0.65, 0, petalLen);
        g.addColorStop(0, rgba(this.color, (0.62 + glow) * this.fade));
        g.addColorStop(1, rgba(this.color, (0.06 + glow*0.25) * this.fade));

        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.moveTo(r*0.12, 0);
        ctx.quadraticCurveTo(petalLen*0.35, -petalWid*0.55, petalLen, 0);
        ctx.quadraticCurveTo(petalLen*0.35,  petalWid*0.55, r*0.12, 0);
        ctx.closePath();
        ctx.fill();

        ctx.shadowBlur = 0;
        ctx.strokeStyle = rgba(this.outline, (0.12 + 0.10*this.z) * this.fade);
        ctx.lineWidth = 1;
        ctx.stroke();

        ctx.restore();
      }

      ctx.shadowBlur = 18 + 24*this.z;
      const cg = ctx.createRadialGradient(0,0, r*0.06, 0,0, r*0.45);
      cg.addColorStop(0, rgba(this.center, (0.95) * this.fade));
      cg.addColorStop(1, rgba(this.center, (0.12) * this.fade));
      ctx.fillStyle = cg;
      ctx.beginPath();
      ctx.arc(0,0, r*0.28, 0, Math.PI*2);
      ctx.fill();

      ctx.shadowBlur = 0;
      ctx.fillStyle = rgba(this.center, 0.65 * this.fade);
      for(let i=0;i<8;i++){
        const a = (i/8)*Math.PI*2;
        ctx.beginPath();
        ctx.arc(Math.cos(a)*r*0.17, Math.sin(a)*r*0.17, r*0.03, 0, Math.PI*2);
        ctx.fill();
      }

      ctx.restore();
    }
  }

  // Background sparkles
  const stars = Array.from({length: 120}, () => ({
    x: Math.random(),
    y: Math.random(),
    r: rand(0.6, 1.6),
    a: rand(0.05, 0.22),
    p: rand(0, Math.PI*2),
    s: rand(0.3, 1.3)
  }));

  function drawBackground(t){
    ctx.clearRect(0,0,W,H);

    ctx.save();
    for(const st of stars){
      const tw = 0.5 + 0.5*Math.sin(t*0.001*st.s + st.p);
      const x = st.x * W;
      const y = st.y * H;
      ctx.globalAlpha = st.a * (0.7 + 0.6*tw);
      ctx.beginPath();
      ctx.arc(x, y, st.r, 0, Math.PI*2);
      ctx.fillStyle = 'white';
      ctx.fill();
    }
    ctx.restore();
    ctx.globalAlpha = 1;

    const vg = ctx.createRadialGradient(W*0.5, H*0.55, Math.min(W,H)*0.15, W*0.5, H*0.55, Math.max(W,H)*0.8);
    vg.addColorStop(0, 'rgba(0,0,0,0)');
    vg.addColorStop(1, 'rgba(0,0,0,0.45)');
    ctx.fillStyle = vg;
    ctx.fillRect(0,0,W,H);
  }

  // Fixed options (no UI)
  function getOptions(){
    const pal = paletteFromPreset(CONFIG.baseColor, CONFIG.preset);
    const center = (CONFIG.preset === 'mono') ? pal[3] : { r: 255, g: 214, b: 98 };
    const outline = { r: 255, g: 255, b: 255 };

    return {
      speed: lerp(0.3, 2.2, clamp(CONFIG.speed,0,1)),
      wind:  lerp(0.0, 2.8, clamp(CONFIG.wind,0,1)),
      size:  CONFIG.size,
      count: CONFIG.count,
      mode:  CONFIG.mode,
      palette: pal,
      center,
      outline,
    };
  }

  let flowers = [];
  let running = true;

  function seedFlowers(force){
    const opt = getOptions();
    const target = opt.count;

    if(force) flowers = [];

    while(flowers.length < target){
      const x = rand(0, W);
      const y = (opt.mode === 'sprout') ? rand(H*0.75, H + 220) : rand(-100, H + 120);
      const color = opt.palette[randi(0, opt.palette.length - 1)];
      flowers.push(new Flower(x, y, {
        size: opt.size,
        speed: opt.speed,
        wind: opt.wind,
        color,
        center: opt.center,
        outline: opt.outline,
        mode: opt.mode,
      }));
    }
    while(flowers.length > target) flowers.pop();
  }

  // Controls (hidden): Space pausa, R regenera, click planta
  window.addEventListener('keydown', (e) => {
    if(e.code === 'Space'){
      e.preventDefault();
      running = !running;
    }
    if(e.key.toLowerCase() === 'r'){
      seedFlowers(true);
    }
  });

  canvas.addEventListener('pointerdown', (e) => {
    const opt = getOptions();
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    const color = opt.palette[randi(0, opt.palette.length - 1)];
    const f = new Flower(x, y, {
      size: opt.size,
      speed: opt.speed,
      wind: opt.wind,
      color,
      center: opt.center,
      outline: opt.outline,
      mode: opt.mode,
    });
    f.fade = 0;
    flowers.push(f);

    const cap = opt.count + 20;
    if(flowers.length > cap) flowers.splice(0, flowers.length - cap);
  });

  seedFlowers(true);

  let lastT = 0;
  function frame(t){
    requestAnimationFrame(frame);

    drawBackground(t);
    const opt = getOptions();
    seedFlowers(false);

    if(!running){
      for(const f of flowers) f.draw();
      return;
    }

    const dt = Math.min(60, t - lastT);
    lastT = t;

    for(const f of flowers){
      f.mode = opt.mode;
      f.step(t, opt);
      f.draw();
    }
  }
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
